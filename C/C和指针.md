使用#define使代码无效比注释更优雅

```c
//函数参数为数组时，下标不起类型检查的作用，且函数内可以访问的下标可能会越界，比如传入两个元素的数组，但是函数内可以访问下标2
void func_test(char arg[2]){
    arg[0] = 1;
    arg[1] = 3;
    arg[2] = 4;
    arg[3] = 9;
}
int main(){
	char buf[5] = { 0 };
	func_test(buf);
	return 0;
}
```

limits.h中有各数据类型的上下限

当数组下标来自于不可靠的来源时，必须做边界检测

定义常量时，使用#define比使用const更好，因为const定义的常量只能使用在可以使用在变量的位置，比如使用在数组下标就不可以

有符号数的右移操作，是不可移植的，因为右移涉及逻辑移位和算术移位的区别

EOF是一个整型值，使用char型变量与EOF相比较是不恰当的，故getchar的返回值是整型而不是char型

P110描述了指针指向数组前方越界和后方越界的情况，二者是有区别的

解引用和使用下标访问本质是一样的，不需要array被声明为数组也可以使用下标访问

```c
*(array+1)
array[1]//解释为*(array+(1))
1[array]//解释为*(1+(array))
```

数组定义会在内存申请一片空间，数组名是一个常量指针，指向这片内存的开头，不可修改

指针定义后未赋任何值，可以做算术运算