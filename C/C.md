# C

编程语言可以分为：机器语言，汇编语言，高级语言
高级语言可以分为：编译型，解释型
C时编译型，即编译出可执行文件直接执行。解释型语言解释一步执行一步

C是通用型语言，即不受平台限制。不同架构的CPU有不同的指令集以及对应的汇编语言，依赖于架构的编译器可以将C程序编译为此架构的汇编程序来适应平台。所以C程序可以在单片机、Intel、AMD各种平台使用，因为每个平台都有编译器。

## 语言标准

美国国家标准协会（ANSI）国际标准化组织（ISO）
ANSI C和ISO C是完全相同的，也叫做C89或C90，常叫做ANSI C
ANSI/ISO联合委员会修订C并发布C99
2011发布C11

## 系统调用

用户程序一般在用户态执行，无法直接使用内核态的服务。需要使用内核态的资源则调用系统调用

系统调用是操作系统提供的，一般又会封装，成为操作系统API

C标准定义了C语言的实现，由两部分组成，C的语法（编译器），C语言标准库。要在一个平台上实现C标准，要实现C编译器与C标准库

Linux平台下最广泛使用的C运行时库是glibc，包含了C标准库和系统函数

不符合C标准的实现也是存在的，例如很多单片机的C 语言开发工具中只有C编译器而没有完整的C标准库

<img src="C:/Users/liteng/Pictures/typora/C/image-20220806103259610.png" alt="image-20220806103259610" style="zoom:50%;" />

# 进程内存

程序运行，系统给程序分配一个进程空间，在程序看来，这段内存是连续的，但是在物理上不是连续的，参见操作系统的虚拟内存机制，程序的各种数据存放在这个进程空间内，按照段分类存放

高地址 

> 命令行参数和环境变量
>
> 栈：自动变量、函数形参、函数
>
> 堆：动态分配的内存
>
> bss：全局变量和静态自动变量未初始化或初始化为0存放于此，程序开始执行前，内核将此段中数据初始化为0或空指针
>
> data：初始化不为0的全局变量和静态自动变量
>
> text：CPU执行的机器指令

低地址

bss的数据不存放在磁盘中，即可执行文件中，需要放在磁盘程序文件中的只有data和text，即可执行文件中

<img src="C:\Users\liteng\Pictures\typora\C/image-20220326131442217.png" alt="image-20220326131442217" style="zoom: 67%;" />

<img src="C:\Users\liteng\Pictures\typora\C/image-20220326131243510.png" alt="image-20220326131243510" style="zoom: 67%;" />

## 数据分类

根据进程内存来理解c语言的变量

data和bss数据存在于程序运行的整个周期，对应全局变量和静态自动变量，两者区别在于作用域

stack数据自动创建销毁，对应自动变量

```c
int i;//bss
int i = 0;//bss
int i = 1;//data
static int i = 0;//bss
static int i = 1;//data
const int i = 0;//text，无论初始化是不是0，加了const都会放在text段
int main(){}
```

## 数据属性

从进程内存的角度很好理解存储期的概念，text、data、bss段在程序执行期间一直存在，栈动态变化

变量作用域、外部链接性、静态属性，属于语言层面的属性

全局变量可以使用const修改可读写性，使用static修改外部链接性

自动变量可以使用const修改可读写性，使用static修改存储期，这个很变态

## 整型

前缀：八进制常数以0开头，通常是无符号数。十六进制常数以0X或0x开头
后缀：在16位字长的机器上，基本整型的长度也是16位，如果使用的数超出范围，需使用长整型，后缀使用L或1，表示无符号数后缀为U或u

## 线程数据

线程有自己的栈，位于进程空间中栈和堆的中间，线程栈互相独立，对应线程中的局部变量不可以互相访问，而进程空间中的data、bss段，线程是可以共享的，对应全局变量，所有线程函数都可以访问，只要声明

# 数据类型

内存所有数据都是0或1，关键在于如何解读这些01，C语言内置类型即默认解码格式，比如char就是解读8位数据，int就是解读4个字节的数据，而结构体就是可以自定义的解读格式，或者说规则，对一块内存按照这个结构体的规则进行解读，按照不同的规则得到不同的结果，值得注意的是别越界

## 数组

作为函数参数时是指针形式

数组名就是一个数组指针，同样也是数组第一个元素的地址，所以可以使用*（arr+1）访问数组第二个元素

声明其他文件的全局数组时，可以不键入大小extern char arr[];

数组作为函数参数传递时，欲知数组大小，常用方法有

​	将大小一并传递

​	使用特殊标志结束数组

​		字符串以字符型数组存储，判断大小可以使用末尾字符位'\0'或NULL

​		与主动创建字符型数组不同，创建字符串会自动在末尾加上'\0'或NULL

​		指针数组总是以空指针结束

使用指针访问数组属于间接引用，比使用下标访问快（需计算下标与数据类型乘积然后加到首地址上）

指针数组
​	数组元素都是指针，int *arr[];

字符数组和字符指针是不同的，sizeof函数可以计算字符数组的大小，包括空字符，但是用在字符指针上计算的是指针大小，strlen函数对两者作用相同

## 结构体

### 数据对齐

编译器会对结构体进行数据对齐优化，有利于cpu访问内存的效率，结果就是结构的大小不等于所有成员大小之和，结构体数据在内存中存在不使用的空当。当使用结构体作为数据流使用时，必须先对齐再发送，对方才能接收到连续的内容。使用结构体指针然后偏移访问成员，成员的偏移量不一定等于前面成员大小之和

```c
//第一种解决办法
typedef struct node_t node_t;
struct node_t{
    char i;
    int j;
}__attribute__((packed));
//第二种解决办法
#pragma pack(1)
typedef struct node_t node_t;
struct node_t{
    char i;
    int j;
}
#pragma pack()
```

结构体指针可以像普通指针一样，先解引用然后改变成员

```c
(*p).value = 10;
```

也可以直接访问成员

```c
p->value = 10;
```

成员在内存不一定相邻存储，对边界要求严格的成员在前，要求不严格的在后，一定程度可以提高利用率。对于可读性的损失，建议使用注释弥补。

```c
#include<stddef.h>
//宏可用来计算结构成员与结构起始位置的偏移量
offsetof(type, member);
```

### 自引用

结构成员是自身的结构是非法的，但可以是自身结构的指针

```c
struct link{
	struct link l;//非法
	struct link *p;//合法
}
```

### 伸缩型数组成员

结构体最后一个成员是一个变长数组

pf = malloc(sizeof(struct flex) + n*sizeof(double));

### 共用体/联合

形似结构体但同一时刻只能存储一个成员，内存大小为最大成员大小

匿名联合在结构体嵌套中有价值，相当于结构体有一个不确定的成员

### 位域

一种特殊的结构体，其成员是不超过8位的bit，也就是可以细化到bit操作存储区

定义时初始化一个变量可以使用	{}	给所有成员赋值，后面单独定义变量时就不可以了

#### 位操作

&：常用来清零数据
^：异或，不同为一
<<：左移，高位丢弃，低位补零

>>：右移，对于正数，高位补零。对于有符号数，符号位将随同移动，
>>​	正数符号位为0，负数为1，补零还是一跟随操作系统

## 指针

保存内存地址的数据类型，大小依赖于平台，32位程序中指针大小为4字节

指针的数据类型表示指向的数据解析方式，void *类型指针不可以解引用，因为不知道指向的内存如何解析，void *这一性质可以一定程度实现多态

```c
int *p = null;//指向int类型数据
int **p = null;//指向int *类型数据，即指向的内存数据也是一个指针，且其指向的内存数据是一个int
```

-----

因指针的特殊性，其只保存地址，所以可以转换其数据类型，以不同的方式解析指向的内存

结构体变量的地址等于其第一个成员的地址，有时候这个特性很有用，node_t类型是一个节点，节点类型打算对用户隐藏，只给用户返回data的指针，同时为了方便删除节点，删除操作参数为节点指针，但是用户只有data指针，此时只需内部将data指针转为node_t型指针即可

```c
typedef struct node_t{
    void *data;
    int num;
}node_t;

void *list_delete(list_t *list, void *data){
    node_t *node = (node_t *)data;//data地址与所在节点地址一样
}
```

-----

指针类型除了影响指向的内存解析方式，还影响指针的算数操作，指针进行加减，保存的内存地址加减的量取决于指针指向的数据类型，比如指向int数组的指针+1，将指向下一个int数组元素，而不是指针保存的地址值加一个字节，这里实际上加了4字节

```c
int *p = &i;
p++;//地址增加一个int类型占用的大小
char *p = &i;
p++;//地址增加一个char类型占用的大小
```

常量指针：const int *p 指针指向的数据是常量，不可修改，但指针指向可修改

指针常量：int * const p 指针本身是个常量，指向不可修改，但是指向的数据可修改

# 函数

## 可变参数

类型va_list

宏va_start、va_arg、va_end

# 关键字

| 关键字   | 作用                                                     |
| -------- | -------------------------------------------------------- |
| extern   | 引用外部链接                                             |
| static   | 改变全局变量链接属性或局部变量存储期                     |
| const    | 限定数据只可读                                           |
| inline   | 内联函数，将函数以机器码插入调用函数的位置，提高运行速度 |
| volatile | 表示直接访问物理地址，不准编译器优化                     |

# 预处理

详见C Primer Plus 第16章

## #line

编译时改变行号和文件名，有利于从编译信息定位bug位置

## #define

宏控制打印开关

```c
#define DEBUG_
#ifdef DEBUG_
#define DEBUG(format, ...) printf("FILE:%s LINE:%d FUNC:%s ERRNO:%d "format, __FILE__, __LINE__, __func__, errno, ##__VA_ARGS__)
#endif
```

## #pragma

1. 设置结构体对齐方式
1. 控制头文件不被重复包含

## extern "C"

```c
extern "C"{
//其中的内容会按照c语言编译，多用于c和c++混合项目
}
```



# 文件

C把文件看作一系列连续的字节，每个字节能够被单独读取

所有文件都是以二进制存储的，但是文件使用二进制编码的字符（ASCII或Unicode）表示文本（如C的字符串），该文件就是文本文件，如果文件的二进制代表机器语言或数值数据，该文件就是二进制文件

以文本模式读写文件时，C会自动将换行转换为自己的\n，写入时转换为平台的换行
以二进制模式读写文件时，C会看到每一个字符，包括\n，\r等

读取文件结尾EOF

#  技巧

## OOP



```c
while((c = getchar()) != null)
```

```c
a = b = c = 0;//多个变量同时初始化
```

# 设计模式

## 工厂模式

根据输入值返回不同的实例对象

# 库

## stdio.h

| 函数                   | 说明                                             |
| :--------------------- | :----------------------------------------------- |
| fgets/fputs            | 向指定流输入/输出一行                            |
| fgetc/fputc            | 向指定流输入/输出一个字符                        |
| fread/fwrite           | 二进制IO，可以指定流                             |
| getchar/putchar        | 单字节标准输入输出，实际上是宏，底层使用fgetc    |
| scanf/sscanf/fscanf    | 格式化输入，从标准输入/字符串/流的输入中提取数据 |
| printf/sprintf/fprintf | 格式化输出，向标准输入/字符串/流的输出中写入数据 |

禁止使用gets和puts甚至getc和putc

fgets会保存换行符

sscanf只能从字符串开头匹配，不可以从字符串中间获取一个字符串片段，可以使用strstr先定位再获取

---

### printf

|      |        |
| ---- | ------ |
| %s   | 字符串 |
| %c   | 字符   |
| %d   | 整数   |
| %f   | 浮点数 |

```c
//%3d表示整数形式至少3个字宽表示
printf("%3d	%6d\n", fahr, celsius);
//%.2f	浮点数打印，小数点后两位
//%6.1f	浮点数打印，至少6字宽，2位小数
```

## string.h

|  查找   |                             说明                             |
| :-----: | :----------------------------------------------------------: |
| memchr  |               搜索前n个字节首次出现字符c的位置               |
| strchr  |             在字符串中搜索第一次出现字符c的位置              |
| strlen  |  计算字符串 str 的长度，直到空结束字符，但不包括空结束字符   |
| strrchr |              在字符串中搜索末次出现字符c的位置               |
| strstr  |           在字符串中查找第一次出现指定字符串的位置           |
| strpbrk | 检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符 |
| strcspn | 检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符 |

1、使用strlen计算的长度来申请内存请记住，申请的内存没有计算结尾空字符，当使用strcpy时，可以赋值给自己，但是释放时，将崩溃，因为strcpy不会复制结尾空字符


|      比较      |           说明            |
| :------------: | :-----------------------: |
|     memcmp     | 把两个字符串前n个字节比较 |
| strcmp/strncmp |      比较两个字符串       |



|    复制拼接    |                         说明                          |
| :------------: | :---------------------------------------------------: |
| memcpy/memmove |              从 src 复制 n 个字符到 dest              |
| strcat/strncat | 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾 |
| strcpy/strncpy |           把 src 所指向的字符串复制到 dest            |



## ctype.h

判断传入的字符是否满足某一条件（字母、数字、空白、十进制、大小写等）

​    满足条件返回非零值，不满足条件返回0值

## stddef.h

|          |                  |
| -------- | ---------------- |
| offsetof | 计算结构体偏移量 |



<signal.h>

```c
#include<signal.h>
```

信号三种响应方式，忽略、缺省（通常是终止程序）、信号处理函数

```c
//显式地引发一个信号
int raise(int sig);
//指定程序希望采取的反应
void (*signal(int sig, void (*handler)(int)))(int);
```

## <setjmp.h>

setjmp记录一个位置，程序调用longjmp时将返回至setjmp

当存在很深的调用链时，可以使用函数返回值来发现错误，但是使用跳转可以去除中间函数的错误逻辑，实现简化

## <assert.h>

断言，要么通过，要么程序终止

## <stdarg.h>

函数可变参数

## <stdlib.h>



## <stdint.h>、<inttype.h>

增加程序的可移植性，前者定义了定宽类型，后者定义了各类型printf占位符

# Linux库

## arpa/inet.h

inet_pton与inet_ntop函数参数需要谨慎填入，因为函数定义是void *，没有类型检测，填入错误可能引发崩溃

# 文本编辑器

​	Linux中常用vi或vim

# 编译器

​	GCC编译流程main.c
​		预处理阶段：加载头文件，生成main.i
​		编译阶段：词法分析、语法分析、语义分析后生成汇编文件，生成main.s
​		汇编阶段：将汇编文件生成二进制文件，生成main.o
​		链接阶段：将所有源文件和库文件链接生成可执行文件，生成main.exe
​	直接生成可执行文件	
​		编译main.c生成main.exe：gcc main.c –o main
​		执行main.exe：.\main.exe

# 调试器

​	调试阶段在开发过程中占相当大的比重，Linux中可使用GDB调试
​	GDB命令行不方便，Eclipse可视化
​	windows中有更多选择

# 工程管理器

​	一个工程有很多源文件，一个一个编译显然不现实
​	工程管理器根据Makefile文件中的编译规则对工程编译
​	GCC提供了半自动化的Make



